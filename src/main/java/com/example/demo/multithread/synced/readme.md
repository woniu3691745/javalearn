##Java同步

> Java同步可在任何线程进入同步代码之前对资源进行锁定和解锁，它必须获得对Object的锁定，并且在代码执行结束时，它会解锁可以被其他线程锁定的资源。同时，其他线程处于等待状态以锁定同步资源。

> 我们可以通过两种方式使用synced关键字，一种是使完整方法同步，另一种方法是创建同步块。

> `同步方法时，它会锁定Object；如果方法是静态的，则它会锁定Class，因此，最佳做法始终是使用同步块来锁定方法中仅需要同步的部分。`

> 创建同步块时，我们需要提供获取锁定的资源，它可以是XYZ.class或该类的任何Object字段。

> `synchronized(this)` 将在进入同步块之前锁定对象。

> 您应该使用最低级别的锁定，例如，如果一个类中有多个同步块，而其中一个正在锁定Object，则其他同步块也将不可用于其他线程执行。当我们锁定一个对象时，它获得了对该对象所有字段的锁定。

> Java同步以性能为代价提供数据完整性，因此仅在绝对必要时才应使用它。

> Java同步仅在同一个JVM中起作用，因此，如果您需要在多个JVM环境中锁定某些资源，则它将无法正常工作，因此您可能需要照顾一些全局锁定机制。

> Java同步关键字不能用于构造函数和变量。

> 最好创建一个虚拟私有对象用于同步块，以使它的引用不能被任何其他代码更改。例如，如果您有一个要在其上同步的Object的setter方法，则可以通过其他一些代码来更改其引用，从而导致并行执行同步块。

> 我们不应该使用在常量池中维护的任何对象，例如，不应将String用于同步，因为如果任何其他代码也锁定在同一String上，它将尝试从String池获取对同一引用对象的锁定，并且即使两个代码无关，它们也会互相锁定。

```java
class c1 {
    //代码块
    //dummy object variable for synchronization 
    private Object mutex = new Object();
        //...
    //using synchronized block to read, increment and update count value synchronously
    synchronized(mutex) {
        count++;
    }
}
```
##如何避免Java中的死锁

>`免嵌套锁`：这是导致死锁的最常见原因，如果已经持有另一个资源，请避免锁定另一个资源。如果仅使用一个对象锁，则几乎不可能出现死锁情况。

>`仅锁定所需条件`：您应该仅对必须处理的资源获取锁定，例如，在上述程序中，我正在锁定完整的Object资源，但是如果我们仅对其中一个字段感兴趣，则应该仅锁定该对象具体字段不完整的对象。

>`避免无限期地等待`：如果两个线程正在使用线程连接无限期地等待对方完成，则可能会出现死锁。如果您的线程必须等待另一个线程完成，则始终最好使用join并在等待线程完成的最长时间内使用它。
